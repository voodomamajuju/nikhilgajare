<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Login - Model Management</title>
  <link rel="stylesheet" href="login.css">
</head>
<body>
  <div class="login-container">
    <h1>Model Management</h1>
    <p class="subtitle">Professional Platform ‚Ä¢ 18+ only</p>
    
    <div class="auth-section">
      <button id="googleSignIn" class="auth-btn google">
        <span class="icon">üîç</span>
        Sign in with Google
      </button>
      
      <div class="divider">
        <span>or</span>
      </div>
      
      <form id="emailForm" class="email-form">
        <input type="email" id="email" placeholder="Enter your email" required pattern="[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$" title="Please enter a valid email address">
        <input type="password" id="password" placeholder="Enter your password" required>
        <button type="submit" class="auth-btn email">Sign In</button>
      </form>
      
              <div class="auth-links">
                <button type="button" id="signUpToggle" class="link-btn">Don't have an account? Sign Up</button>
                <button type="button" id="logoutBtn" class="link-btn logout" style="display: none;">Logout & Clear Session</button>
              </div>
    </div>
    
    <div id="status" class="status-message"></div>
  </div>


  <script type="module">
    console.log('üöÄ Login page script starting...');
    
    // Initialize Supabase with error handling
    let supabase = null;
    
    // Initialize Supabase - use dynamic imports
    (async function initSupabase() {
      try {
        const { createClient } = await import("https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm");
        const config = await import("./config.public.js");
        const SUPABASE_URL = config.SUPABASE_URL;
        const SUPABASE_ANON_KEY = config.SUPABASE_ANON_KEY;
        
        if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
          throw new Error('Supabase configuration is missing');
        }
        supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        console.log("‚úÖ Supabase client initialized");
        
        // Store supabase globally for other functions
        window.supabase = supabase;
        
        // Wait for DOM, then initialize the page
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initializePage);
        } else {
          initializePage();
        }
      } catch (error) {
        console.error('‚ùå Failed to initialize Supabase:', error);
        const statusEl = document.getElementById('status');
        if (statusEl) {
          statusEl.textContent = 'Error: Failed to load authentication. Please refresh the page.';
          statusEl.className = 'status-message error';
          statusEl.style.display = 'block';
        }
        // Still try to initialize page even if Supabase fails
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initializePage);
        } else {
          initializePage();
        }
      }
    })();
    
    // Clear any existing session data on login page load
    console.log('üßπ Clearing session data on login page load');
    sessionStorage.removeItem('userRole');

    async function redirectToApp() {
      if (!supabase) {
        console.error('‚ùå Cannot redirect - Supabase not initialized');
        return;
      }
      // For regular users, check if they have an existing submission
      try {
        const { data: { user } } = await supabase.auth.getUser();
        if (user) {
          // Check if user has an existing submission
          const { data: submission, error } = await supabase
            .from('submissions')
            .select('*')
            .eq('user_id', user.id)
            .maybeSingle();
          
          if (submission && !error) {
            console.log('üìã User has existing submission, redirecting to submission details');
            // Redirect to a submission details/edit page
            window.location.href = 'submission-details.html';
                  } else {
                    console.log('üìù No existing submission, redirecting to form');
                    // No existing submission, redirect to form for new users
                    window.location.href = 'form.html';
                  }
        } else {
          // No user, stay on login page
          console.log('üë§ No user session, staying on login page');
        }
      } catch (error) {
        console.error('‚ùå Error checking existing submission:', error);
        // Redirect to form on error as fallback
        console.log('‚ö†Ô∏è Error occurred, redirecting to form as fallback');
        window.location.href = 'form.html';
      }
    }

    function showStatus(message, isError = false) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status-message ${isError ? 'error' : 'success'}`;
      status.style.display = 'block';
    }
    
    // Initialize page - run after DOM is ready
    async function initializePage() {
      // Check for email verification callback from Supabase
      const urlParams = new URLSearchParams(window.location.search);
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      
      // Check for Supabase auth callback (type=recovery or type=signup)
      const type = urlParams.get('type') || hashParams.get('type');
      const token = urlParams.get('token') || hashParams.get('access_token');
      
      if (type === 'signup' || type === 'recovery' || urlParams.get('verified') === '1') {
        console.log('üìß Email verification callback detected:', { type, token: !!token });
        
        // If there's a token, exchange it for a session
        if (token && supabase) {
          try {
            const { data, error } = await supabase.auth.getSession();
            if (error) {
              console.error('Error getting session after verification:', error);
            } else if (data.session) {
              console.log('‚úÖ Session created after email verification');
              showStatus("‚úÖ Email verified successfully! You can now proceed.", false);
              // Redirect after a short delay
              setTimeout(() => {
                window.location.href = 'form.html';
              }, 2000);
            }
          } catch (err) {
            console.error('Error handling verification:', err);
            showStatus("‚úÖ Email verified! Please sign in to continue.", false);
          }
        } else {
          showStatus("‚úÖ Email verified successfully! You can now sign in.", false);
        }
        
        // Clean up URL
        window.history.replaceState({}, document.title, window.location.pathname);
      }
      
      // Check if user is already logged in
      let session = null;
      if (supabase) {
        try {
          const { data } = await supabase.auth.getSession();
          session = data?.session;
        } catch (err) {
          console.error('Error getting session:', err);
        }
      }
      const shouldAuto = urlParams.get('auto') === '1'; // only auto-redirect when explicitly requested
      if (session) {
        // Show logout button for signed-in users
        const logoutBtn = document.getElementById('logoutBtn');
        if (logoutBtn) logoutBtn.style.display = 'block';
        
        // Only auto-redirect after explicit flows (e.g., OAuth), and not from thank you page
        if (shouldAuto && urlParams.get('from') !== 'thankyou') {
          // Check if this is an admin by email
          const userEmail = session.user.email;
          console.log('üîç Checking user email:', userEmail);
          
          if (userEmail === 'admin@example.com' || userEmail === 'nikhil.dg2003@gmail.com') {
            console.log('üîÑ Admin email detected, redirecting to admin.html');
            sessionStorage.setItem('userRole', 'admin');
            window.location.href = 'admin.html';
          } else {
            console.log('üë§ Regular user detected, checking submission');
            sessionStorage.setItem('userRole', 'user');
            await redirectToApp();
          }
        } else {
          console.log('‚ÑπÔ∏è Session present, staying on login (no auto param).');
        }
      }

      // Listen for auth changes
      if (supabase) {
        supabase.auth.onAuthStateChange(async (event, session) => {
      console.log('üîç Auth state changed:', event, session?.user?.email);
      if (event === 'SIGNED_IN' && session) {
        console.log('‚úÖ User signed in, redirecting...');
        // Check if this is an admin login by email
        const userEmail = session.user.email;
        if (userEmail === 'admin@example.com' || userEmail === 'nikhil.dg2003@gmail.com') {
          console.log('üîÑ Admin email detected, redirecting to admin.html');
          sessionStorage.setItem('userRole', 'admin');
          window.location.href = 'admin.html';
        } else {
          console.log('üë§ Regular user detected, checking for existing submission');
          sessionStorage.setItem('userRole', 'user');
          await redirectToApp();
        }
      } else if (event === 'SIGNED_OUT') {
        console.log('üëã User signed out');
        // Clear user role on logout
        sessionStorage.removeItem('userRole');
        document.getElementById('logoutBtn').style.display = 'none';
        }
      });
      } else {
        console.error('‚ùå Cannot set up auth state listener - Supabase not initialized');
      }

      // Google OAuth - ensure button exists before attaching listener
      const googleSignInBtn = document.getElementById("googleSignIn");
      if (googleSignInBtn) {
        console.log('üîµ Found Google sign-in button, attaching listener...');
        googleSignInBtn.addEventListener("click", async (e) => {
          e.preventDefault();
          console.log('üîµ Google sign-in button clicked!');
          if (!supabase) {
            console.error('‚ùå Supabase not initialized');
            showStatus("Error: Authentication not available. Please refresh the page.", true);
            return;
          }
          try {
            console.log('üîµ Initiating Google OAuth...');
            const { error } = await supabase.auth.signInWithOAuth({
              provider: "google",
              options: {
                // Return with auto=1 to enable single-shot auto-redirect after OAuth only
                redirectTo: window.location.origin + "/login.html?auto=1"
              }
            });
            if (error) {
              console.error('‚ùå Google sign-in error:', error);
              showStatus("Google sign-in failed: " + error.message, true);
            } else {
              console.log('‚úÖ Google sign-in initiated successfully');
            }
          } catch (err) {
            console.error('‚ùå Google sign-in exception:', err);
            showStatus("Google sign-in failed: " + err.message, true);
          }
        });
        console.log('‚úÖ Google sign-in button event listener attached');
      } else {
        console.error('‚ùå Google sign-in button not found! Check HTML for id="googleSignIn"');
      }

      // Logout button
      const logoutBtn = document.getElementById("logoutBtn");
    if (logoutBtn) {
      logoutBtn.addEventListener("click", async () => {
        if (!supabase) {
          showStatus("Error: Authentication not available.", true);
          return;
        }
        try {
          await supabase.auth.signOut();
        sessionStorage.clear();
        localStorage.clear();
        showStatus("Logged out successfully! Session cleared.", false);
        document.getElementById('logoutBtn').style.display = 'none';
        console.log('‚úÖ Logout completed, session cleared');
      } catch (error) {
        console.error('‚ùå Logout error:', error);
        showStatus("Logout failed: " + error.message, true);
      }
    });
    }

      // Sign up/Sign in toggle - ensure it's attached after DOM is ready
      const signUpToggleBtn = document.getElementById("signUpToggle");
      if (signUpToggleBtn) {
        console.log('üîµ Found sign up toggle button, attaching listener...');
        signUpToggleBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('üîµ Toggle button clicked!');
          const submitBtn = document.querySelector(".email-form .auth-btn");
          if (!submitBtn) {
            console.error('‚ùå Submit button not found');
            return;
          }
          
          const isCurrentlySignUp = submitBtn.textContent.trim() === "Sign Up";
          console.log('Toggle clicked, currently sign up mode:', isCurrentlySignUp);
          
          if (isCurrentlySignUp) {
            submitBtn.textContent = "Sign In";
            signUpToggleBtn.textContent = "Don't have an account? Sign Up";
          } else {
            submitBtn.textContent = "Sign Up";
            signUpToggleBtn.textContent = "Already have an account? Sign In";
          }
        });
        console.log('‚úÖ Sign up toggle button event listener attached');
      } else {
        console.error('‚ùå Sign up toggle button not found! Check HTML for id="signUpToggle"');
      }

      // Email validation function (same as contact.js) - Enhanced version
      function validateEmail(email) {
      if (!email) return { valid: false, message: 'Email is required' };
      
      // Trim whitespace
      email = email.trim();
      
      // Check for common typos
      if (email.includes(' ')) {
        return { valid: false, message: 'Email cannot contain spaces' };
      }
      
      if (email.includes('..')) {
        return { valid: false, message: 'Email cannot contain consecutive dots' };
      }
      
      if (email.startsWith('.') || email.startsWith('@')) {
        return { valid: false, message: 'Email cannot start with . or @' };
      }
      
      if (email.endsWith('.') || email.endsWith('@')) {
        return { valid: false, message: 'Email cannot end with . or @' };
      }
      
      // Enhanced format validation - more strict
      const emailRegex = /^[a-zA-Z0-9]([a-zA-Z0-9._-]*[a-zA-Z0-9])?@[a-zA-Z0-9]([a-zA-Z0-9.-]*[a-zA-Z0-9])?\.[a-zA-Z]{2,}$/;
      if (!emailRegex.test(email)) {
        return { valid: false, message: 'Please enter a valid email format (e.g., name@example.com)' };
      }
      
      // Check email length
      if (email.length > 320) {
        return { valid: false, message: 'Email is too long (maximum 320 characters)' };
      }
      
      const [localPart, domain] = email.split('@');
      if (!localPart || !domain) {
        return { valid: false, message: 'Invalid email format' };
      }
      
      if (localPart.length > 64) {
        return { valid: false, message: 'Email username part is too long' };
      }
      if (domain && domain.length > 255) {
        return { valid: false, message: 'Email domain is too long' };
      }
      
      // Check for valid TLD
      const domainParts = domain?.split('.');
      if (!domainParts || domainParts.length < 2 || domainParts[domainParts.length - 1].length < 2) {
        return { valid: false, message: 'Email must have a valid domain (e.g., .com, .org)' };
      }
      
      // Filter out inappropriate content in email addresses
      const inappropriateWords = [
        // Profanity and offensive terms
        'fuck', 'fuckboy', 'fuckgirl', 'fucking', 'shit', 'asshole', 'bitch', 'bastard',
        'damn', 'hell', 'crap', 'piss', 'dick', 'cock', 'pussy', 'whore', 'slut',
        'nigger', 'nigga', 'retard', 'gay', 'lesbian', 'homo', 'fag', 'tranny',
        'kill', 'murder', 'death', 'suicide', 'bomb', 'terrorist', 'hack', 'scam',
        'spam', 'fake', 'test123', 'temp', 'temporary', 'throwaway', 'trash',
        'iamyourdad', 'iamyourmom', 'yourmom', 'yourdad', 'yourmum', 'yourfather',
        'lavdalasan', 'bullshit', 'stupid', 'idiot', 'moron', 'dumb', 'loser',
        'hate', 'ugly', 'fat', 'skinny', 'dumbass', 'ass', 'butt',
        'sex', 'porn', 'xxx', 'nude', 'naked', 'horny', 'sexy', 'hot', 'boobs',
        'drug', 'weed', 'cocaine', 'heroin', 'alcohol', 'drunk', 'high',
        'violence', 'gun', 'weapon', 'knife', 'blood', 'gore', 'torture'
      ];
      
      // Blacklist of known temporary/fake email services
      const fakeEmailDomains = [
        'tempmail.com', 'tempmail.net', 'tempmail.org', 'tempmail.co',
        '10minutemail.com', '10minutemail.net', '10minutemail.org',
        'guerrillamail.com', 'guerrillamail.net', 'guerrillamail.org',
        'mailinator.com', 'mailinator.net', 'mailinator.org',
        'throwaway.email', 'throwawaymail.com', 'throwawaymail.net',
        'fakemail.com', 'fakemail.net', 'fakemail.org',
        'temp-mail.org', 'temp-mail.com', 'temp-mail.net',
        'mohmal.com', 'mohmal.net', 'mohmal.org',
        'yopmail.com', 'yopmail.net', 'yopmail.org',
        'getnada.com', 'getnada.net', 'getnada.org',
        'maildrop.cc', 'maildrop.com', 'maildrop.net',
        'sharklasers.com', 'sharklasers.net', 'sharklasers.org',
        'trashmail.com', 'trashmail.net', 'trashmail.org',
        'dispostable.com', 'dispostable.net', 'dispostable.org',
        'meltmail.com', 'meltmail.net', 'meltmail.org',
        'mintemail.com', 'mintemail.net', 'mintemail.org',
        'mytrashmail.com', 'mytrashmail.net', 'mytrashmail.org',
        'tempail.com', 'tempail.net', 'tempail.org',
        'emailondeck.com', 'emailondeck.net', 'emailondeck.org',
        'mailcatch.com', 'mailcatch.net', 'mailcatch.org',
        'spamgourmet.com', 'spamgourmet.net', 'spamgourmet.org',
        'test.com', 'test.net', 'test.org', 'test123.com', 'test123.net',
        'example.com', 'example.net', 'example.org',
        'fake.com', 'fake.net', 'fake.org', 'fakemail.com',
        'dummy.com', 'dummy.net', 'dummy.org',
        'invalid.com', 'invalid.net', 'invalid.org'
      ];
      
      const emailLower = email.toLowerCase();
      const localPartLower = localPart.toLowerCase();
      const domainLower = domain.toLowerCase();
      
      // Check for fake/temporary email domains
      if (fakeEmailDomains.includes(domainLower)) {
        return { valid: false, message: 'Temporary or fake email addresses are not allowed. Please use a real email address.' };
      }
      
      // Check for inappropriate words in local part or domain
      for (const word of inappropriateWords) {
        if (localPartLower.includes(word) || domainLower.includes(word)) {
          return { valid: false, message: 'Email contains inappropriate content. Please use a professional email address.' };
        }
      }
      
      // Check for suspicious patterns (like random strings, numbers only, etc.)
      // Reject if local part is just numbers or very short random strings
      if (/^[0-9]+$/.test(localPart) && localPart.length < 5) {
        return { valid: false, message: 'Email appears to be invalid. Please use a real email address.' };
      }
      
      // Reject if local part is too short (likely fake)
      if (localPart.length < 3) {
        return { valid: false, message: 'Email address is too short. Please use a valid email address.' };
      }
      
      // Email verification is handled by Supabase, so we just validate format
      return { valid: true, message: 'Email looks good!' };
      }

      // Email/Password authentication - ensure form exists
      const emailForm = document.getElementById("emailForm");
      if (!emailForm) {
        console.error('‚ùå Email form not found!');
      } else {
        emailForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      const email = document.getElementById("email").value;
      const password = document.getElementById("password").value;
      const submitBtnText = document.querySelector(".email-form .auth-btn").textContent;
      const isSignUp = submitBtnText === "Sign Up";

      // Validate email before proceeding
      const emailValidation = validateEmail(email);
      if (!emailValidation.valid) {
        showStatus(`‚ùå ${emailValidation.message}`, 'error');
        return;
      }

      console.log('üîç Auth attempt:', { 
        email, 
        isSignUp, 
        toggleText: document.getElementById("signUpToggle").textContent,
        submitBtnText 
      });

      if (!supabase) {
        showStatus("Error: Authentication not available. Please refresh the page.", true);
        return;
      }
      
      try {
        if (isSignUp) {
          // Sign up with email confirmation required
          // Use the current origin (works for both custom domain and netlify)
          const redirectUrl = window.location.origin + '/login.html?verified=1';
          console.log('üîó Email redirect URL:', redirectUrl);
          
          const { data, error } = await supabase.auth.signUp({ 
            email, 
            password,
            options: {
              emailRedirectTo: redirectUrl
            }
          });
          
          if (error) {
            console.error('Sign up error:', error);
            throw error;
          }
          
          console.log('Sign up response:', { user: !!data.user, session: !!data.session });
          
          // Check if email confirmation is required
          if (data.user && !data.session) {
            // Email confirmation required
            showStatus("‚úÖ Sign up successful! Please check your email to verify your account. Click the link in the email to continue.", false);
            console.log('üìß Email verification required, user:', data.user.email);
            return; // Don't redirect, wait for email verification
          } else if (data.session) {
            // Email confirmation not required (or already verified)
            showStatus("Sign up successful! Redirecting to form...");
            setTimeout(() => {
              console.log('üéâ Sign up completed, redirecting to form.html');
              window.location.href = 'form.html';
            }, 1000);
          } else {
            // Fallback
            showStatus("Sign up successful! Please check your email.", false);
          }
        } else {
          // Sign in - redirect to existing submission or main form
          const { data, error } = await supabase.auth.signInWithPassword({ email, password });
          if (error) throw error;
          showStatus("Sign in successful! Redirecting...");
          // The redirect will be handled by the auth state change listener
        }
      } catch (error) {
        console.error('‚ùå Auth error:', error);
        showStatus("Authentication failed: " + error.message, true);
      }
        });
        console.log('‚úÖ Email form event listener attached');
      }
      
      // If Supabase failed to initialize, show error
      if (!supabase) {
        console.error('‚ùå Cannot proceed - Supabase not initialized');
        // Still allow form to show, but disable functionality
        const emailForm = document.getElementById("emailForm");
        if (emailForm) {
          emailForm.style.opacity = '0.5';
          emailForm.style.pointerEvents = 'none';
        }
        const googleBtn = document.getElementById("googleSignIn");
        if (googleBtn) {
          googleBtn.style.opacity = '0.5';
          googleBtn.style.pointerEvents = 'none';
        }
      } else {
        console.log('‚úÖ All systems ready - authentication available');
      }
    }
    
    // initializePage is called from initSupabase after DOM is ready
  </script>
</body>
</html>